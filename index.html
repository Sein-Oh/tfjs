<!DOCTYPE html>
<html>

<head>
    <title>Tensorflow.js</title>
</head>

<body>
    <p>Press 'F12' on your Chrome browser and See console.</p>
    <button value='circle' onclick="openImageFiles(this.value, makeDataSet)" style="width:100px; height:50px">Circle</button>
    <button value='rectangle' onclick="openImageFiles(this.value, makeDataSet)" style="width:100px; height:50px">Rectangle</button>
    <button value='triangle' onclick="openImageFiles(this.value, makeDataSet)" style="width:100px; height:50px">Triangle</button>
    <br><br>
    <button onclick="modelFit()" style="width:310px; height:50px">Training</button>
    <br><br>
    <button value='test' onclick="openImageFiles(this.value, makeTestSet)" style="width:310px; height:50px">Load test image and predict</button>
    <div id='board'></div>
</body>
<script src='https://cdnjs.cloudflare.com/ajax/libs/tensorflow/1.2.2/tf.js'></script>
<script>
    const label = ['circle', 'rectangle', 'triangle'];
    const numOfClass = label.length;
    const board = document.getElementById('board');
    //Use onehot : circle[1,0,0], rectangle[0,1,0], triangle[0,0,1]
    function openImageFiles(className, callback) {
        const input = document.createElement('input');
        input.type = 'file';
        input.multiple = 'multiple';
        input.onchange = function (evt) {
            for (let d of evt.target.files) {
                const fileName = d.name;
                const url = URL.createObjectURL(d)
                const img = new Image();
                img.onload = function () {
                    if(className == 'test') board.appendChild(img);
                    let tens = tf.browser.fromPixels(img).div(255.0).expandDims(); //div를 하지 않은경우 제대로 되지 않음.
                    callback([className, tens, fileName]);
                }
                img.src = url;
            }
        };
        input.click();
    }

    let xs, ys;
    function makeDataSet(dataSet) {
        if (typeof xs === 'undefined') {
            xs = dataSet[1];
            ys = toOnehot(dataSet[0]);
        }
        else {
            xs = xs.concat(dataSet[1]);
            ys = ys.concat(toOnehot(dataSet[0]));
        }
        console.log('Added %s data.', dataSet[0]);
        //console.log(xs.shape);
        //console.log(ys.shape);
    }

    function toOnehot(label) {
        let y;
        if (label == 'circle') y = tf.tensor1d([1, 0, 0], 'int32').expandDims();
        else if (label == 'rectangle') y = tf.tensor1d([0, 1, 0], 'int32').expandDims();
        else if (label == 'triangle') y = tf.tensor1d([0, 0, 1], 'int32').expandDims();
        else if (label == 'test') y = "Predict doesn't need y.";
        return y;
    }

    let x, y;
    function makeTestSet(dataSet){
        x = dataSet[1];
        y = toOnehot(dataSet[0]);
        setTimeout(predict, 0);
    }

    async function makeCNN() {
        const model = tf.sequential();
        model.add(tf.layers.conv2d({
            filters: 32,
            kernelSize: 3,
            activation: 'relu',
            inputShape: [24, 24, 3],
            strides: 1,
            kernelInitializer: 'varianceScaling'
        }));
        model.add(tf.layers.conv2d({
            filters: 64,
            kernelSize: 3,
            activation: 'relu'
        }));
        model.add(tf.layers.maxPooling2d({
            poolSize: [2,2]
        }));
        model.add(tf.layers.flatten());
        model.add(tf.layers.dense({
            units: 128, 
            activation: 'relu'
        }));
        model.add(tf.layers.dense({
            units: numOfClass, 
            activation: 'softmax'
        }));

        model.compile({
            loss: 'categoricalCrossentropy',
            optimizer: tf.train.adam(),
            metrics: ['accuracy']
        });
        return model;
    }

    function onBatchEnd(batch, logs){
        console.log("loss", logs.loss.toFixed(6));
    }

    let model;
    async function modelFit(){
        model = await makeCNN();
        await model.summary();
        console.log("Let's start training...")
        await model.fit(xs, ys, {
            stepsPerEpoch: 15,
            epochs: 12,
            callbacks : {onBatchEnd}
        });
        console.log("Complete training.")
    }

    let myPredict;
    async function predict(){
        myPredict = await model.predict(x).data();
        const myProb = Math.max.apply(null, myPredict);
        const myLabel = label[myPredict.indexOf(myProb)];
        console.log('My prediction : %s', myLabel);
        console.log('Probability : %f', myProb.toFixed(4));
    }
</script>

</html>
